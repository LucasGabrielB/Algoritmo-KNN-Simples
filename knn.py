#  -*- coding: utf-8 -*-
#
# Author: Lucas Gabriel B

"""clasificacao.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UMMUy3TlPOiIBgETFXaSQkbuiLERbmcy

#k-nearest neighbors algorithm
This is a simple example of an algorithm that implements KNN.
"""

# import modules
import numpy as np
import matplotlib.pyplot as plt

# training data (just a simple exemple)
train_data = [[1, 1], [2, 2.5], [3, 1.2], [5.5, 6.3], [6, 9], [7, 6]]
train_data_groups = ['red', 'red', 'red', 'blue', 'blue', 'blue']

# plot the graph with all the points
def plot_scatter():
    plt.figure()
    plt.grid()
    plt.scatter([x[0] for x in train_data], [y[1] for y in train_data],
                color = train_data_groups, edgecolor='black')
    plt.show()


def dist(a, b):
    ''' Calculate distance between two points in any dimension. 
        
        Args:
            a (list): The first point.
            b (list): The second point.

        Returns:
            float: Euclidean distance between points a b  
    
        Raises:
            ValueError: If points 'a' and 'b' have different dimensions.
    '''

    if len(a) != len(b):
        raise Exception('Points have different dimensions.')

    distance = 0

    # for each dimension of space
    for i in range(len(a)):
        # (a - b) squared
        distance += (b[i] - a[i]) ** 2 

    # square root the sum of all (a - b) squared

    # return the distance
    return distance ** (1/2)

def calculate_dists(test_data, print_result=True, add_data=True):
    ''' Calculates the distance between all 'train_data' 
        and the 'test_data'.

                
        Args:
            test_data (list): A list containing the coordinates of the test point.       
            print_result (bool): If True prints a sequence of information,
                the distances and groups and also to which group the test_data belongs.
            add_data (bool): If True add the point to the train_data

    '''

    # list containing the distance to all points
    distancs = list()
    
    # for each data in train_data
    for data in train_data:
        # add distance to list
        distancs.append(dist(test_data, data))

    # which group belongs to the point closest to the test value
    test_data_group = train_data_groups[distancs.index(min(distancs))]

    if print_result:
        # prints distances and groups
        print(list(zip(distancs, train_data_groups)))
        print(f"The new point belongs to the group\n '{test_data_group}'.")

    if add_data:
        # add the 'test_data' to the 'train_data'
        add_new_data(test_data, test_data_group)

def add_new_data(point, group):
    ''' Adds a new point and its respective group to the data
        
        Args:
            point (list): A list containing each point coordinate.
            group (list): The group to which the point belongs.
    '''
    # append values
    train_data.append(point)
    train_data_groups.append(group)


plot_scatter()

"""> The code below is used to generate random coordinates in order to test the 
algorithm. the coordinates created will be automatically added later to the '*train_data*'.
"""

# import module random
import random

test_data = [0, 0]
# generate n random coordinates
for i in range(3000):
    x = round(random.uniform(0 ,10), 2)
    y = round(random.uniform(0 ,10), 2)
    test_data = x, y

    calculate_dists(test_data, print_result=False)


plot_scatter()
